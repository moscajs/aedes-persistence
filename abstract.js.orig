const { Readable } = require('node:stream')
const { promisify } = require('node:util')
const Packet = require('aedes-packet')

function waitForEvent (obj, resolveEvt) {
  return new Promise((resolve, reject) => {
    obj.once(resolveEvt, () => {
      resolve()
    })
    obj.once('error', reject)
  })
}

function doCleanup (t, instance) {
  instance.destroy(() => {
    t.diagnostic('instance destroyed')
  })
}

function abstractPersistence (opts) {
  const test = opts.test
  let _persistence = opts.persistence
  const waitForReady = opts.waitForReady

  // requiring it here so it will not error for modules
  // not using the default emitter
  const buildEmitter = opts.buildEmitter || require('mqemitter')

  if (_persistence.length === 0) {
    _persistence = function asyncify (cb) {
      cb(null, opts.persistence())
    }
  }

  const _asyncPersistence = promisify(_persistence)
  async function persistence (t) {
    const mq = buildEmitter()
    const broker = {
      id: 'broker-42',
      mq,
      publish: mq.emit.bind(mq),
      subscribe: mq.on.bind(mq),
      unsubscribe: mq.removeListener.bind(mq),
      counter: 0
    }

    const instance = await _asyncPersistence()
    if (instance) {
      // Wait for ready event, if applicable, to ensure the persistence isn't
      // destroyed while it's still being set up.
      // https://github.com/mcollina/aedes-persistence-redis/issues/41
      if (waitForReady) {
        await waitForEvent(instance, 'ready')
      }
      instance.broker = broker
      t.diagnostic('instance created')
      return instance
    }
    throw new Error('no instance')
  }

  // legacy third party streams are typically not iterable
  function iterableStream (stream) {
    if (typeof stream[Symbol.asyncIterator] !== 'function') {
      return new Readable({ objectMode: true }).wrap(stream)
    }
    return stream
  }
  // end of legacy third party streams support

  async function getArrayFromStream (stream) {
    const list = []
    for await (const item of iterableStream(stream)) {
      list.push(item)
    }
    return list
  }

  async function streamForEach (stream, fn) {
    for await (const item of iterableStream(stream)) {
      await fn(item)
    }
  }

  function asyncStoreRetained (instance, packet) {
    return new Promise((resolve, reject) => {
      instance.storeRetained(packet, err => {
        if (err) {
          reject(err)
        } else {
          resolve()
        }
      })
    })
  }

  async function storeRetained (instance, opts = {}) {
    const packet = {
      cmd: 'publish',
      id: instance.broker.id,
      topic: opts.topic || 'hello/world',
      payload: opts.payload || Buffer.from('muahah'),
      qos: 0,
      retain: true
    }
    await asyncStoreRetained(instance, packet)
    return packet
  }

  async function matchRetainedWithPattern (t, pattern, opts) {
    const instance = await persistence(t)
    const packet = await storeRetained(instance, opts)
    let stream
    if (Array.isArray(pattern)) {
      stream = instance.createRetainedStreamCombi(pattern)
    } else {
      stream = instance.createRetainedStream(pattern)
    }
    t.diagnostic('created stream')
    const list = await getArrayFromStream(stream)
    t.assert.deepEqual(list, [packet], 'must return the packet')
    t.diagnostic('stream was ok')
    doCleanup(t, instance)
  }

  function testPacket (t, packet, expected) {
    if (packet.messageId === null) packet.messageId = undefined
    t.assert.equal(packet.messageId, undefined, 'should have an unassigned messageId in queue')
    // deepLooseEqual?
    t.assert.deepEqual(structuredClone(packet), expected, 'must return the packet')
  }

  function deClassed (obj) {
    return Object.assign({}, obj)
  }

  // testing starts here
  test('store and look up retained messages', async t => {
    t.plan(1)
    await matchRetainedWithPattern(t, 'hello/world')
  })

  test('look up retained messages with a # pattern', async t => {
    t.plan(1)
    await matchRetainedWithPattern(t, '#')
  })

  test('look up retained messages with a hello/world/# pattern', async t => {
    t.plan(1)
    await matchRetainedWithPattern(t, 'hello/world/#')
  })

  test('look up retained messages with a + pattern', async t => {
    t.plan(1)
    await matchRetainedWithPattern(t, 'hello/+')
  })

  test('look up retained messages with multiple patterns', async t => {
    t.plan(1)
    await matchRetainedWithPattern(t, ['hello/+', 'other/hello'])
  })

  test('store multiple retained messages in order', async (t) => {
    t.plan(1000)
    const instance = await persistence(t)
    const totalMessages = 1000

    const retained = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      retain: true
    }

    for (let i = 0; i < totalMessages; i++) {
      const packet = new Packet(retained, instance.broker)
      await storeRetained(instance, packet)
      t.assert.equal(packet.brokerCounter, i + 1, 'packet stored in order')
    }
    doCleanup(t, instance)
  })

  test('remove retained message', async (t) => {
    const instance = await persistence(t)
    await storeRetained(instance, {})
    await storeRetained(instance, {
      payload: Buffer.alloc(0)
    })
    const stream = instance.createRetainedStream('#')
    const list = await getArrayFromStream(stream)
    t.assert.deepEqual(list, [], 'must return an empty list')
    doCleanup(t, instance)
  })

  test('storing twice a retained message should keep only the last', async (t) => {
    const instance = await persistence(t)
    await storeRetained(instance, {})
    const packet = await storeRetained(instance, {
      payload: Buffer.from('ahah')
    })
    const stream = instance.createRetainedStream('#')
    const list = await getArrayFromStream(stream)
    t.assert.deepEqual(list, [packet], 'must return the last packet')
    doCleanup(t, instance)
  })

  test('Create a new packet while storing a retained message', async (t) => {
    const instance = await persistence(t)
    const packet = {
      cmd: 'publish',
      id: instance.broker.id,
      topic: opts.topic || 'hello/world',
      payload: opts.payload || Buffer.from('muahah'),
      qos: 0,
      retain: true
    }
    const newPacket = Object.assign({}, packet)

    await asyncStoreRetained(instance, packet)
    // packet reference change to check if a new packet is stored always
    packet.retain = false
    const stream = instance.createRetainedStream('#')
    const list = await getArrayFromStream(stream)
    t.assert.deepEqual(list, [newPacket], 'must return the last packet')
    doCleanup(t, instance)
  })

  test('store and look up subscriptions by client', async (t) => {
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'matteo',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'noqos',
      qos: 0,
      rh: 0,
      rap: true,
      nl: false
    }]

    instance.addSubscriptions(client, subs, (err, reClient) => {
      t.assert.equal(reClient, client, 'client must be the same')
      t.assert.ok(!err, 'no error')
      instance.subscriptionsByClient(client, (err, resubs, reReClient) => {
        t.assert.equal(reReClient, client, 'client must be the same')
        t.assert.ok(!err, 'no error')
        t.assert.deepEqual(resubs, subs)
        doCleanup(t, instance)
      })
    })
  })

  async function addSubscriptions (instance, client, subs) {
    return new Promise((resolve, reject) => {
      instance.addSubscriptions(client, subs, (err, reClient) => {
        if (err) {
          reject(err)
        } else {
          resolve(reClient)
        }
      })
    })
  }

  async function removeSubscriptions (instance, client, subs) {
    return new Promise((resolve, reject) => {
      instance.removeSubscriptions(client, subs, (err, reClient) => {
        if (err) {
          reject(err)
        } else {
          resolve(reClient)
        }
      })
    })
  }

  async function subscriptionsByClient (instance, client) {
    return new Promise((resolve, reject) => {
      instance.subscriptionsByClient(client, (err, resubs, reClient) => {
        if (err) {
          reject(err)
        } else {
          resolve({ resubs, reClient })
        }
      })
    })
  }

  async function subscriptionsByTopic (instance, topic) {
    return new Promise((resolve, reject) => {
      instance.subscriptionsByTopic(topic, (err, resubs) => {
        if (err) {
          reject(err)
        } else {
          resolve(resubs)
        }
      })
    })
  }

  async function cleanSubscriptions (instance, client) {
    return new Promise((resolve, reject) => {
      instance.cleanSubscriptions(client, (err) => {
        if (err) {
          reject(err)
        } else {
          resolve()
        }
      })
    })
  }

  async function countOffline (instance) {
    return new Promise((resolve, reject) => {
      instance.countOffline((err, subsCount, clientsCount) => {
        if (err) {
          reject(err)
        } else {
          resolve({ subsCount, clientsCount })
        }
      })
    })
  }

  async function outgoingEnqueue (instance, sub, packet) {
    return new Promise((resolve, reject) => {
      instance.outgoingEnqueue(sub, packet, err => {
        if (err) {
          reject(err)
        } else {
          resolve()
        }
      })
    })
  }

  async function outgoingEnqueueCombi (instance, subs, packet) {
    return new Promise((resolve, reject) => {
      instance.outgoingEnqueueCombi(subs, packet, err => {
        if (err) {
          reject(err)
        } else {
          resolve()
        }
      })
    })
  }

  test('remove subscriptions by client', async (t) => {
    t.plan(4)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'matteo',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]

    const reclient1 = await addSubscriptions(instance, client, subs)
    t.assert.equal(reclient1, client, 'client must be the same')
    const reClient2 = await removeSubscriptions(instance, client, ['hello'])
    t.assert.equal(reClient2, client, 'client must be the same')
    const { resubs, reClient } = await subscriptionsByClient(instance, client)
    t.assert.equal(reClient, client, 'client must be the same')
    t.assert.deepEqual(resubs, [{
      topic: 'matteo',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }])
    doCleanup(t, instance)
  })

  test('store and look up subscriptions by topic', async (t) => {
    t.plan(2)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'hello/#',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'matteo',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]

    const reclient = await addSubscriptions(instance, client, subs)
    t.assert.equal(reclient, client, 'client must be the same')
    const resubs = await subscriptionsByTopic(instance, 'hello')
    t.assert.deepEqual(resubs, [{
      clientId: client.id,
      topic: 'hello/#',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      clientId: client.id,
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }])
    doCleanup(t, instance)
  })

  test('get client list after subscriptions', async (t) => {
    t.plan(1)
    const instance = await persistence(t)
    const client1 = { id: 'abcde' }
    const client2 = { id: 'efghi' }
    const subs = [{
      topic: 'helloagain',
      qos: 1
    }]

    await addSubscriptions(instance, client1, subs)
    await addSubscriptions(instance, client2, subs)
    const stream = instance.getClientList(subs[0].topic)
    const list = await getArrayFromStream(stream)
    t.assert.deepEqual(list, [client1.id, client2.id])
    doCleanup(t, instance)
  })

  test('get client list after an unsubscribe', async (t) => {
    t.plan(1)
    const instance = await persistence(t)
    const client1 = { id: 'abcde' }
    const client2 = { id: 'efghi' }
    const subs = [{
      topic: 'helloagain',
      qos: 1
    }]
    await addSubscriptions(instance, client1, subs)
    await addSubscriptions(instance, client2, subs)
    await removeSubscriptions(instance, client2, [subs[0].topic])
    const stream = instance.getClientList(subs[0].topic)
    const list = await getArrayFromStream(stream)
    t.assert.deepEqual(list, [client1.id])
    doCleanup(t, instance)
  })

  test('get subscriptions list after an unsubscribe', async (t) => {
    t.plan(1)
    const instance = await persistence(t)
    const client1 = { id: 'abcde' }
    const client2 = { id: 'efghi' }
    const subs = [{
      topic: 'helloagain',
      qos: 1
    }]
    await addSubscriptions(instance, client1, subs)
    await addSubscriptions(instance, client2, subs)
    await removeSubscriptions(instance, client2, [subs[0].topic])
    const clients = await subscriptionsByTopic(instance, subs[0].topic)
    t.assert.deepEqual(clients[0].clientId, client1.id)
    doCleanup(t, instance)
  })

  test('QoS 0 subscriptions, restored but not matched', async (t) => {
    t.plan(2)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 0,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'hello/#',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'matteo',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]

    await addSubscriptions(instance, client, subs)
    const { resubs } = await subscriptionsByClient(instance, client)
    t.assert.deepEqual(resubs, subs)
    const resubs2 = await subscriptionsByTopic(instance, 'hello')
    t.assert.deepEqual(resubs2, [{
      clientId: client.id,
      topic: 'hello/#',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }])
    doCleanup(t, instance)
  })

  test('clean subscriptions', async (t) => {
    t.plan(4)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 1
    }, {
      topic: 'matteo',
      qos: 1
    }]

    await addSubscriptions(instance, client, subs)
    await cleanSubscriptions(instance, client)
    const resubs = await subscriptionsByTopic(instance, 'hello')
    t.assert.deepEqual(resubs, [], 'no subscriptions')
    const { resubs: resubs2 } = await subscriptionsByClient(instance, client)
    t.assert.deepEqual(resubs2, null, 'no subscriptions')
    const { subsCount, clientsCount } = await countOffline(instance)
    t.assert.equal(subsCount, 0, 'no subscriptions added')
    t.assert.equal(clientsCount, 0, 'no clients added')
    doCleanup(t, instance)
  })

  test('clean subscriptions with no active subscriptions', async (t) => {
    t.plan(4)
    const instance = await persistence(t)
    const client = { id: 'abcde' }

    await cleanSubscriptions(instance, client)
    const resubs = await subscriptionsByTopic(instance, 'hello')
    t.assert.deepEqual(resubs, [], 'no subscriptions')
    const { resubs: resubs2 } = await subscriptionsByClient(instance, client)
    t.assert.deepEqual(resubs2, null, 'no subscriptions')
    const { subsCount, clientsCount } = await countOffline(instance)
    t.assert.equal(subsCount, 0, 'no subscriptions added')
    t.assert.equal(clientsCount, 0, 'no clients added')
    doCleanup(t, instance)
  })

  test('same topic, different QoS', async (t) => {
    t.plan(5)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 0,
      rh: 0,
      rap: true,
      nl: false
    }, {
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]

    const reClient = await addSubscriptions(instance, client, subs)
    t.assert.equal(reClient, client, 'client must be the same')
    const { resubs } = await subscriptionsByClient(instance, client)
    t.assert.deepEqual(resubs, [{
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }])

    const resubs2 = await subscriptionsByTopic(instance, 'hello')
    t.assert.deepEqual(resubs2, [{
      clientId: 'abcde',
      topic: 'hello',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }])

    const { subsCount, clientsCount } = await countOffline(instance)
    t.assert.equal(subsCount, 1, 'one subscription added')
    t.assert.equal(clientsCount, 1, 'one client added')
    doCleanup(t, instance)
  })

  test('replace subscriptions', async (t) => {
    t.plan(25)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const topic = 'hello'
    const sub = { topic, rh: 0, rap: true, nl: false }
    const subByTopic = { clientId: client.id, topic, rh: 0, rap: true, nl: false }

    async function check (qos) {
      sub.qos = subByTopic.qos = qos
      const reClient = await addSubscriptions(instance, client, [sub])
      t.assert.equal(reClient, client, 'client must be the same')
      const { resubs } = await subscriptionsByClient(instance, client)
      t.assert.deepEqual(resubs, [sub])
      const subsForTopic = await subscriptionsByTopic(instance, topic)
      t.assert.deepEqual(subsForTopic, qos === 0 ? [] : [subByTopic])
      const { subsCount, clientsCount } = await countOffline(instance)
      if (qos === 0) {
        t.assert.equal(subsCount, 0, 'no subscriptions added')
      } else {
        t.assert.equal(subsCount, 1, 'one subscription added')
      }
      t.assert.equal(clientsCount, 1, 'one client added')
    }

    await check(0)
    await check(1)
    await check(2)
    await check(1)
    await check(0)
    doCleanup(t, instance)
  })

  test('replace subscriptions in same call', async (t) => {
    t.plan(5)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const topic = 'hello'
    const subs = [
      { topic, qos: 0, rh: 0, rap: true, nl: false },
      { topic, qos: 1, rh: 0, rap: true, nl: false },
      { topic, qos: 2, rh: 0, rap: true, nl: false },
      { topic, qos: 1, rh: 0, rap: true, nl: false },
      { topic, qos: 0, rh: 0, rap: true, nl: false }
    ]
    const reClient = await addSubscriptions(instance, client, subs)
    t.assert.equal(reClient, client, 'client must be the same')
    const { resubs: subsForClient } = await subscriptionsByClient(instance, client)
    t.assert.deepEqual(subsForClient, [{ topic, qos: 0, rh: 0, rap: true, nl: false }])
    const subsForTopic = await subscriptionsByTopic(instance, topic)
    t.assert.deepEqual(subsForTopic, [])
    const { subsCount, clientsCount } = await countOffline(instance)
    t.assert.equal(subsCount, 0, 'no subscriptions added')
    t.assert.equal(clientsCount, 1, 'one client added')
    doCleanup(t, instance)
  })

  test('store and count subscriptions', async (t) => {
    t.plan(11)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs = [{
      topic: 'hello',
      qos: 1
    }, {
      topic: 'matteo',
      qos: 1
    }, {
      topic: 'noqos',
      qos: 0
    }]

    const reclient = await addSubscriptions(instance, client, subs)
    t.assert.equal(reclient, client, 'client must be the same')
    const { subsCount, clientsCount } = await countOffline(instance)
    t.assert.equal(subsCount, 2, 'two subscriptions added')
    t.assert.equal(clientsCount, 1, 'one client added')
    await removeSubscriptions(instance, client, ['hello'])
    const { subsCount: subsCount2, clientsCount: clientsCount2 } = await countOffline(instance)
    t.assert.equal(subsCount2, 1, 'one subscription added')
    t.assert.equal(clientsCount2, 1, 'one client added')
    await removeSubscriptions(instance, client, ['matteo'])
    const { subsCount: subsCount3, clientsCount: clientsCount3 } = await countOffline(instance)
    t.assert.equal(subsCount3, 0, 'zero subscriptions added')
    t.assert.equal(clientsCount3, 1, 'one client added')
    await removeSubscriptions(instance, client, ['noqos'])
    const { subsCount: subsCount4, clientsCount: clientsCount4 } = await countOffline(instance)
    t.assert.equal(subsCount4, 0, 'zero subscriptions added')
    t.assert.equal(clientsCount4, 0, 'zero clients added')
    await removeSubscriptions(instance, client, ['noqos'])
    const { subsCount: subsCount5, clientsCount: clientsCount5 } = await countOffline(instance)
    t.assert.equal(subsCount5, 0, 'zero subscriptions added')
    t.assert.equal(clientsCount5, 0, 'zero clients added')
    doCleanup(t, instance)
  })

  test('count subscriptions with two clients', async (t) => {
    t.plan(26)
    const instance = await persistence(t)
    const client1 = { id: 'abcde' }
    const client2 = { id: 'fghij' }
    const subs = [{
      topic: 'hello',
      qos: 1
    }, {
      topic: 'matteo',
      qos: 1
    }, {
      topic: 'noqos',
      qos: 0
    }]

    async function remove (client, subs, expectedSubs, expectedClients) {
      const reClient = await removeSubscriptions(instance, client, subs)
      t.assert.equal(reClient, client, 'client must be the same')
      const { subsCount, clientsCount } = await countOffline(instance)
      t.assert.equal(subsCount, expectedSubs, 'subscriptions added')
      t.assert.equal(clientsCount, expectedClients, 'clients added')
    }

    const reClient1 = await addSubscriptions(instance, client1, subs)
    t.assert.equal(reClient1, client1, 'client must be the same')
    const reClient2 = await addSubscriptions(instance, client2, subs)
    t.assert.equal(reClient2, client2, 'client must be the same')
    await remove(client1, ['foobar'], 4, 2)
    await remove(client1, ['hello'], 3, 2)
    await remove(client1, ['hello'], 3, 2)
    await remove(client1, ['matteo'], 2, 2)
    await remove(client1, ['noqos'], 2, 1)
    await remove(client2, ['hello'], 1, 1)
    await remove(client2, ['matteo'], 0, 1)
    await remove(client2, ['noqos'], 0, 0)
    doCleanup(t, instance)
  })

  test('add duplicate subs to persistence for qos > 0', async (t) => {
    t.plan(3)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const topic = 'hello'
    const subs = [{
      topic,
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]

    const reClient = await addSubscriptions(instance, client, subs)
    t.assert.equal(reClient, client, 'client must be the same')
    const reClient2 = await addSubscriptions(instance, client, subs)
    t.assert.equal(reClient2, client, 'client must be the same')
    subs[0].clientId = client.id
    const subsForTopic = await subscriptionsByTopic(instance, topic)
    t.assert.deepEqual(subsForTopic, subs)
    doCleanup(t, instance)
  })

  test('add duplicate subs to persistence for qos 0', async (t) => {
    t.plan(3)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const topic = 'hello'
    const subs = [{
      topic,
      qos: 0,
      rh: 0,
      rap: true,
      nl: false
    }]

    const reClient = await addSubscriptions(instance, client, subs)
    t.assert.equal(reClient, client, 'client must be the same')
    const reClient2 = await addSubscriptions(instance, client, subs)
    t.assert.equal(reClient2, client, 'client must be the same')
    const { resubs: subsForClient } = await subscriptionsByClient(instance, client)
    t.assert.deepEqual(subsForClient, subs)
    doCleanup(t, instance)
  })

  test('get topic list after concurrent subscriptions of a client', async (t) => {
    t.plan(3)
    const instance = await persistence(t)
    const client = { id: 'abcde' }
    const subs1 = [{
      topic: 'hello1',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]
    const subs2 = [{
      topic: 'hello2',
      qos: 1,
      rh: 0,
      rap: true,
      nl: false
    }]
    let calls = 2

    await new Promise((resolve, reject) => {
      async function done () {
        if (!--calls) {
          const { resubs } = await subscriptionsByClient(instance, client)
          resubs.sort((a, b) => a.topic.localeCompare(b.topic, 'en'))
          t.assert.deepEqual(resubs, [subs1[0], subs2[0]])
          doCleanup(t, instance)
          resolve()
        }
      }

      instance.addSubscriptions(client, subs1, err => {
        t.assert.ok(!err, 'no error for hello1')
        done()
      })
      instance.addSubscriptions(client, subs2, err => {
        t.assert.ok(!err, 'no error for hello2')
        done()
      })
    })
  })

  test('add outgoing packet and stream it', async (t) => {
    t.plan(2)
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde',
      topic: 'hello',
      qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42
    }
    const expected = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      retain: false,
      dup: false,
      brokerId: instance.broker.id,
      brokerCounter: 42,
      messageId: undefined
    }

    await outgoingEnqueue(instance, sub, packet)
    const stream = instance.outgoingStream(client)
    const list = await getArrayFromStream(stream)
    testPacket(t, list[0], expected)
    doCleanup(t, instance)
  })

  test('add outgoing packet for multiple subs and stream to all', async (t) => {
    t.plan(4)
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde',
      topic: 'hello',
      qos: 1
    }
    const sub2 = {
      clientId: 'fghih',
      topic: 'hello',
      qos: 1
    }
    const subs = [sub, sub2]
    const client = {
      id: sub.clientId
    }
    const client2 = {
      id: sub2.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42
    }
    const expected = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      retain: false,
      dup: false,
      brokerId: instance.broker.id,
      brokerCounter: 42,
      messageId: undefined
    }

    await outgoingEnqueueCombi(instance, subs, packet)
    const stream = instance.outgoingStream(client)
    const list = await getArrayFromStream(stream)
    testPacket(t, list[0], expected)

    const stream2 = instance.outgoingStream(client2)
    const list2 = await getArrayFromStream(stream2)
    testPacket(t, list2[0], expected)
    doCleanup(t, instance)
  })

  test('add outgoing packet as a string and pump', async (t) => {
    t.plan(7)
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde',
      topic: 'hello',
      qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet1 = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 10
    }
    const packet2 = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('matteo'),
      qos: 1,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 50
    }
    const queue = []

    const updated1 = await asyncEnqueueAndUpdate(t, instance, client, sub, packet1, 42)
    const updated2 = await asyncEnqueueAndUpdate(t, instance, client, sub, packet2, 43)
    const stream = instance.outgoingStream(client)

    async function clearQueue (data) {
      const { repacket } = await outgoingUpdate(instance, client, data)
      t.diagnostic('packet received')
      queue.push(repacket)
    }

    await streamForEach(stream, clearQueue)
    t.assert.equal(queue.length, 2)
    t.assert.deepEqual(deClassed(queue[0]), deClassed(updated1))
    t.assert.deepEqual(deClassed(queue[1]), deClassed(updated2))
    doCleanup(t, instance)
  })

  test('add outgoing packet as a string and stream', async (t) => {
    t.plan(2)
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde',
      topic: 'hello',
      qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: 'world',
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42
    }
    const expected = {
      cmd: 'publish',
      topic: 'hello',
      payload: 'world',
      qos: 1,
      retain: false,
      dup: false,
      brokerId: instance.broker.id,
      brokerCounter: 42,
      messageId: undefined
    }

    await outgoingEnqueueCombi(instance, [sub], packet)
    const stream = instance.outgoingStream(client)
    const list = await getArrayFromStream(stream)
    testPacket(t, list[0], expected)
    doCleanup(t, instance)
  })

  test('add outgoing packet and stream it twice', async (t) => {
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde',
      topic: 'hello',
      qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42,
      messageId: 4242
    }
    const expected = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      retain: false,
      dup: false,
      brokerId: instance.broker.id,
      brokerCounter: 42,
      messageId: undefined
    }

    await outgoingEnqueueCombi(instance, [sub], packet)
    const stream = instance.outgoingStream(client)
    const list = await getArrayFromStream(stream)
    testPacket(t, list[0], expected)
    const stream2 = instance.outgoingStream(client)
    const list2 = await getArrayFromStream(stream2)
    testPacket(t, list2[0], expected)
    t.assert.notEqual(packet, expected, 'packet must be a different object')
    doCleanup(t, instance)
  })

  async function enqueueAndUpdate (t, instance, client, sub, packet, messageId) {
    await outgoingEnqueueCombi(instance, [sub], packet)
    const updated = new Packet(packet)
    updated.messageId = messageId

    const { reclient, repacket } = await outgoingUpdate(instance, client, updated)
    t.assert.equal(reclient, client, 'client matches')
    t.assert.equal(repacket, updated, 'packet matches')
    return repacket
  }

  async function outgoingUpdate (instance, client, packet) {
    return new Promise((resolve, reject) => {
      instance.outgoingUpdate(client, packet, (err, reclient, repacket) => {
        if (err) {
          reject(err)
        } else {
          resolve({ reclient, repacket })
        }
      })
    })
  }

  async function asyncEnqueueAndUpdate (t, instance, client, sub, packet, messageId) {
    await outgoingEnqueueCombi(instance, [sub], packet)
    const updated = new Packet(packet)
    updated.messageId = messageId
    const { reclient, repacket } = await outgoingUpdate(instance, client, updated)
    t.assert.equal(reclient, client, 'client matches')
    t.assert.equal(repacket, updated, 'packet matches')
    return updated
  }

  test('add outgoing packet and update messageId', async (t) => {
    t.plan(5)
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde', topic: 'hello', qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42
    }

    const updated = await enqueueAndUpdate(t, instance, client, sub, packet, 42)
    delete updated.messageId
    const stream = instance.outgoingStream(client)
    const list = await getArrayFromStream(stream)
    delete list[0].messageId
    t.assert.notEqual(list[0], updated, 'must not be the same object')
    t.assert.deepEqual(deClassed(list[0]), deClassed(updated), 'must return the packet')
    t.assert.equal(list.length, 1, 'must return only one packet')
    doCleanup(t, instance)
  })

  test('add 2 outgoing packet and clear messageId', async (t) => {
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde', topic: 'hello', qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet1 = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42
    }
    const packet2 = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('matteo'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 43
    }

    const updated1 = await enqueueAndUpdate(t, instance, client, sub, packet1, 42)
    const updated2 = await enqueueAndUpdate(t, instance, client, sub, packet2, 43)
    instance.outgoingClearMessageId(client, updated1, async (err, packet) => {
      t.assert.ifError(err)
      t.assert.deepEqual(packet.messageId, 42, 'must have the same messageId')
      t.assert.deepEqual(packet.payload.toString(), packet1.payload.toString(), 'must have original payload')
      t.assert.deepEqual(packet.topic, packet1.topic, 'must have original topic')
      const stream = instance.outgoingStream(client)
      delete updated2.messageId
      const list = await getArrayFromStream(stream)
      delete list[0].messageId
      t.assert.notEqual(list[0], updated2, 'must not be the same object')
      t.assert.deepEqual(deClassed(list[0]), deClassed(updated2), 'must return the packet')
      t.assert.equal(list.length, 1, 'must return only one packet')
      doCleanup(t, instance)
    })
  })

  test('add many outgoing packets and clear messageIds', async (t) => {
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde', topic: 'hello', qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 1,
      dup: false,
      length: 14,
      retain: false
    }

    function outStream (instance, client) {
      return iterableStream(instance.outgoingStream(client))
    }

    // we just need a stream to figure out the high watermark
    const stream = outStream(instance, client)
    const total = stream.readableHighWaterMark * 2

    function submitMessage (id) {
      return new Promise((resolve, reject) => {
        const p = new Packet(packet, instance.broker)
        p.messageId = id
        instance.outgoingEnqueue(sub, p, (err) => {
          if (err) {
            return reject(err)
          }
          instance.outgoingUpdate(client, p, resolve)
        })
      })
    }

    function clearMessage (p) {
      return new Promise((resolve, reject) => {
        instance.outgoingClearMessageId(client, p, (err, received) => {
          t.assert.ifError(err)
          t.assert.deepEqual(received, p, 'must return the packet')
          resolve()
        })
      })
    }

    for (let i = 0; i < total; i++) {
      await submitMessage(i)
    }

    let queued = 0
    for await (const p of outStream(instance, client)) {
      if (p) {
        queued++
      }
    }
    t.assert.equal(queued, total, `outgoing queue must hold ${total} items`)

    for await (const p of outStream(instance, client)) {
      await clearMessage(p)
    }

    let queued2 = 0
    for await (const p of outStream(instance, client)) {
      if (p) {
        queued2++
      }
    }
    t.assert.equal(queued2, 0, 'outgoing queue is empty')
    doCleanup(t, instance)
  })

  test('update to publish w/ same messageId', async (t) => {
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde', topic: 'hello', qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet1 = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 2,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42,
      messageId: 42
    }
    const packet2 = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 2,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 50,
      messageId: 42
    }

    instance.outgoingEnqueue(sub, packet1, () => {
      instance.outgoingEnqueue(sub, packet2, () => {
        instance.outgoingUpdate(client, packet1, () => {
          instance.outgoingUpdate(client, packet2, () => {
            const stream = instance.outgoingStream(client)
            getArrayFromStream(stream).then(list => {
              t.assert.equal(list.length, 2, 'must have two items in queue')
              t.assert.equal(list[0].brokerCounter, packet1.brokerCounter, 'brokerCounter must match')
              t.assert.equal(list[0].messageId, packet1.messageId, 'messageId must match')
              t.assert.equal(list[1].brokerCounter, packet2.brokerCounter, 'brokerCounter must match')
              t.assert.equal(list[1].messageId, packet2.messageId, 'messageId must match')
              doCleanup(t, instance)
            })
          })
        })
      })
    })
  })

  test('update to pubrel', async (t) => {
    const instance = await persistence(t)
    const sub = {
      clientId: 'abcde', topic: 'hello', qos: 1
    }
    const client = {
      id: sub.clientId
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 2,
      dup: false,
      length: 14,
      retain: false,
      brokerId: instance.broker.id,
      brokerCounter: 42
    }

    instance.outgoingEnqueueCombi([sub], packet, err => {
      t.assert.ifError(err)
      const updated = new Packet(packet)
      updated.messageId = 42

      instance.outgoingUpdate(client, updated, (err, reclient, repacket) => {
        t.assert.ifError(err)
        t.assert.equal(reclient, client, 'client matches')
        t.assert.equal(repacket, updated, 'packet matches')

        const pubrel = {
          cmd: 'pubrel',
          messageId: updated.messageId
        }

        instance.outgoingUpdate(client, pubrel, err => {
          t.assert.ifError(err)

          const stream = instance.outgoingStream(client)

          getArrayFromStream(stream).then(list => {
            t.assert.deepEqual(list, [pubrel], 'must return the packet')
            doCleanup(t, instance)
          })
        })
      })
    })
  })

  test('add incoming packet, get it, and clear with messageId', async (t) => {
    const instance = await persistence(t)
    const client = {
      id: 'abcde'
    }
    const packet = {
      cmd: 'publish',
      topic: 'hello',
      payload: Buffer.from('world'),
      qos: 2,
      dup: false,
      length: 14,
      retain: false,
      messageId: 42
    }

    instance.incomingStorePacket(client, packet, err => {
      t.assert.ifError(err)

      instance.incomingGetPacket(client, {
        messageId: packet.messageId
      }, (err, retrieved) => {
        t.assert.ifError(err)

        // adjusting the objects so they match
        delete retrieved.brokerCounter
        delete retrieved.brokerId
        delete packet.length
        // strip the class identifier from the packet
        const result = structuredClone(retrieved)
        // Convert Uint8 to Buffer for comparison
        result.payload = Buffer.from(result.payload)
        t.assert.deepEqual(result, packet, 'retrieved packet must be deeply equal')
        t.assert.notEqual(retrieved, packet, 'retrieved packet must not be the same object')

        instance.incomingDelPacket(client, retrieved, err => {
          t.assert.ifError(err)
          instance.incomingGetPacket(client, {
            messageId: packet.messageId
          }, (err, retrieved) => {
            t.assert.ok(err, 'must error')
            doCleanup(t, instance)
          })
        })
      })
    })
  })

  test('store, fetch and delete will message', async (t) => {
    const instance = await persistence(t)
    const client = {
      id: '12345'
    }
    const expected = {
      topic: 'hello/died',
      payload: Buffer.from('muahahha'),
      qos: 0,
      retain: true
    }

    instance.putWill(client, expected, (err, c) => {
      t.assert.ifError(err, 'no error')
      t.assert.equal(c, client, 'client matches')
      instance.getWill(client, (err, packet, c) => {
        t.assert.ifError(err, 'no error')
        t.assert.deepEqual(packet, expected, 'will matches')
        t.assert.equal(c, client, 'client matches')
        client.brokerId = packet.brokerId
        instance.delWill(client, (err, packet, c) => {
          t.assert.ifError(err, 'no error')
          t.assert.deepEqual(packet, expected, 'will matches')
          t.assert.equal(c, client, 'client matches')
          instance.getWill(client, (err, packet, c) => {
            t.assert.ifError(err, 'no error')
            t.assert.ok(!packet, 'no will after del')
            t.assert.equal(c, client, 'client matches')
            doCleanup(t, instance)
          })
        })
      })
    })
  })

  test('stream all will messages', async (t) => {
    const instance = await persistence(t)
    const client = {
      id: '12345',
      brokerId: instance.broker.id
    }
    const toWrite = {
      topic: 'hello/died',
      payload: Buffer.from('muahahha'),
      qos: 0,
      retain: true
    }

    instance.putWill(client, toWrite, (err, c) => {
      t.assert.ifError(err, 'no error')
      t.assert.equal(c, client, 'client matches')
      streamForEach(instance.streamWill(), (chunk) => {
        t.assert.deepEqual(chunk, {
          clientId: client.id,
          brokerId: instance.broker.id,
          topic: 'hello/died',
          payload: Buffer.from('muahahha'),
          qos: 0,
          retain: true
        }, 'packet matches')
        instance.delWill(client, (err, result, client) => {
          t.assert.ifError(err, 'no error')
          doCleanup(t, instance)
        })
      })
    })
  })

  test('stream all will message for unknown brokers', async (t) => {
    const instance = await persistence(t)
    const originalId = instance.broker.id
    const client = {
      id: '42',
      brokerId: instance.broker.id
    }
    const anotherClient = {
      id: '24',
      brokerId: instance.broker.id
    }
    const toWrite1 = {
      topic: 'hello/died42',
      payload: Buffer.from('muahahha'),
      qos: 0,
      retain: true
    }
    const toWrite2 = {
      topic: 'hello/died24',
      payload: Buffer.from('muahahha'),
      qos: 0,
      retain: true
    }

    instance.putWill(client, toWrite1, (err, c) => {
      t.assert.ifError(err, 'no error')
      t.assert.equal(c, client, 'client matches')
      instance.broker.id = 'anotherBroker'
      instance.putWill(anotherClient, toWrite2, (err, c) => {
        t.assert.ifError(err, 'no error')
        t.assert.equal(c, anotherClient, 'client matches')
        streamForEach(instance.streamWill({
          anotherBroker: Date.now()
        }), (chunk) => {
          t.assert.deepEqual(chunk, {
            clientId: client.id,
            brokerId: originalId,
            topic: 'hello/died42',
            payload: Buffer.from('muahahha'),
            qos: 0,
            retain: true
          }, 'packet matches')
          instance.delWill(client, (err, result, client) => {
            t.assert.ifError(err, 'no error')
            doCleanup(t, instance)
          })
        })
      })
    })
  })

  test('delete wills from dead brokers', async (t) => {
    const instance = await persistence(t)
    const client = {
      id: '42'
    }

    const toWrite1 = {
      topic: 'hello/died42',
      payload: Buffer.from('muahahha'),
      qos: 0,
      retain: true
    }

    instance.putWill(client, toWrite1, (err, c) => {
      t.assert.ifError(err, 'no error')
      t.assert.equal(c, client, 'client matches')
      instance.broker.id = 'anotherBroker'
      client.brokerId = instance.broker.id
      instance.delWill(client, (err, result, client) => {
        t.assert.ifError(err, 'no error')
        doCleanup(t, instance)
      })
    })
  })

  test('do not error if unkown messageId in outoingClearMessageId', async (t) => {
    const instance = await persistence(t)
    const client = {
      id: 'abc-123'
    }

    instance.outgoingClearMessageId(client, 42, err => {
      t.assert.ifError(err)
      doCleanup(t, instance)
    })
  })
}

module.exports = abstractPersistence
